El programa recibe por argumentos una serie de números enteros.

Gestión de errores:

-Tienen que haber dos números o más. V
-No se pueden repetir números. V
-Los números deben de ser enteros. V
-Los argumentos han de ser números. V
-Cuando te pasan los argumentos por una variable (ARG="1 2 4 6 5 7") hay que splitear el argumento en varios y atoiarlos.

Si solo hay un argumento
    mientras sea distinto del fin
        char *array = splitter(array);

ARG = "11 223 33 434 54 6643 7 83"

**result

Los argumentos tienen que ir a una pila A. También tenemos que crear una pila b vacía. V

Creamos un nodo por cada argumento recibido (ARRAY SIZE - 1 PARA EVITAR METER EL '\0') (previamente lo hemos metido en un array para hacer la gestión de errores). V


FALLOS:

-Si uno de los elementos es un 0, la función ft_is_sort se confunde, lo toma como '\0' y no funciona bien. // SOLUSIONAO
-Aún permite números repetidos. // Solucionado
-No coge aún un único argumento entrecomillado.

-Definitivamente hay un 0 como primer nodo. Es el head y no pasa nada.
En nums[i] está entrando un número que no queremos y nos lo estamos llevando 
al stack. Se está creando un nodo con mierda al final. //SOLUCIONADO

-Ahora no fufa el sort checker ni el dup checker // SOLUCIONADO



SORT LOT: 

-Encontramos el número máximo
-Dividimos entre cinco para hallar el tamaño de un chunk
-Escaneamos A desde arriba para encontrar un número de chunk 1.
-Escaneamos A desde abajo para encontrar otro número de chunk 1.
-Comparamos cuántos movimientos hay que hacer para llevar hold first y hold second arriba.
-Si el número está en la primera mitad del stack, usaremos ra. Si está en la segunda, rra.
-Llevamos arriba el que menos movimientos cueste.
-¿Buscar el mejor spot en b para meterlo?
-Repetir para el chunk 2 3 4 y 5.
-Cuando Stack A esté vacío, vaciamos B ordenado.


101  100  99  98  97  96  95  94  93  92  91  90  89  88  87  86  85  84  83  82  81  80  79  78  77  76  75  74  73  72  71  70  69  68  67  66  65  64  63  62  61  60  59  58  57  56  55  54  53  52  51  50  49  48  47  46  45  43  42  41  40  39  38  37  36  35  34  33  32  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10  9  8  7  6  5  4  3  2  1



